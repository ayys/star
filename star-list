#!/usr/bin/env bash

export _STAR_DIR_SEPARATOR="Â»"

usage() {
    cat << EOF
    Usage: star-list DIR [LIST_MODE] [OPTIONS]...
           star-list DIR ITEM_MODE

    DIR                         Relative or absolute path.

    LIST_MODE: To display the starred directorus. Choose one of the following list modes (exclusives):
        -n, --names             Only print the star's names.
        -p, --paths             Only print the star's paths.
        -f, --format=FORMAT     Print with a custom format. See "Formatting".

            Formatting:
            The format value will be passed to the "printf" option of GNU find, meaning its formatting can be used.
            This script also provide the following formatting:
                <INDEX>     will be replaced by an index

    OPTIONS:
        -s, --sort={name|loaded|none}
        -o, --order={desc|asc}
        -i, --index={none|desc|asc}     Only with "--format".
        -b, --broken                    Only search for broken symlinks.
    
    ITEM_MODE: To retrieve a single bit of information
        -P, --get-path=NAME     Get the path of a star according to its name
        -N, --get-name=PATH     Get the name of a star according to its path
EOF
}

MAX_DEPTH=1

# Possible values for options
MODE_NAMES="names"
MODE_PATHS="paths"
MODE_CUSTOM_FORMAT="custom-format"
MODE_GET_PATH="get-path"
MODE_GET_NAME="get-name"

SORT_NAME="name"
SORT_LOADED="loaded"
SORT_NONE="none"

ORDER_DESC="desc"
ORDER_ASC="asc"

INDEX_NONE="none"
INDEX_DESC="desc"
INDEX_ASC="asc"


# Default values
MODE=$MODE_NAMES
FORMAT="\n"

SORT=$SORT_LOADED
ORDER=$ORDER_DESC
INDEX=$INDEX_ASC

DIR=

# by default, search for non broken symlinks
TYPE_TEST="-type l -not -xtype l"

# TODO: source config file with environment variables

list_stars() {
    if [[ $# -lt 1 ]]; then
        return 1
    fi
    local custom_format="$1"

    if [[ "$SORT" == "$SORT_NONE" ]]; then
        find "$DIR" -maxdepth "$MAX_DEPTH" $TYPE_TEST -printf "$format"
        return $?
    fi

    local format=""
    local sort_options="--numeric-sort"

    # the sort is applied to the first "column"
    # this column is delimited by the first whitespace, and will be removed before printing
    case $SORT in
        "$SORT_LOADED" ) format="%As $format" ;;
        "$SORT_NAME" ) format="%f $format" ;;
    esac

    # one result per line
    format="$format $custom_format\n"

    # apply the sort order
    # by default, sorting with numeric values (last loaded time) is smaller number to higher,
    # but we want a descending order, so we need to reverse it if sort=loaded and order is desc
    if [[ "$SORT" == "$SORT_LOADED" && "$ORDER" == "$ORDER_DESC" 
        || "$SORT" == "$SORT_NAME" && "$ORDER" == "$ORDER_ASC" ]]; then
        sort_options="$sort_options  --reverse"
    fi

    find "$DIR" -maxdepth "$MAX_DEPTH" $TYPE_TEST -printf "$format" | sort $sort_options | cut -d' ' -f3-
}

list_names() {
    list_stars "%f"
}

list_paths() {
    list_stars "%l"
}

list_custom_format() {
    local stars=()
    while IFS= read -r; do
        stars+=("$REPLY")
    done < <(list_stars "$FORMAT")

    if [[ "$FORMAT" == *"<INDEX>"* ]]; then
        local index
        [[ "$INDEX" == "$INDEX_ASC" ]] && index=1 || index="${#stars[@]}"

        for s in "${stars[@]}"; do
            echo "${s//<INDEX>/$index}"
            [[ "$INDEX" == "$INDEX_ASC" ]] && ((index++)) || ((index--))
        done
    else
        for s in "${stars[@]}"; do
            echo "$s"
        done
    fi
}

get_item_name() {
    list_stars "%f %l\n" | grep " ${GET_NAME}$" | head -n1 | cut -d' ' -f1
}

get_item_path() {
    list_stars "%f %l\n" | grep "^${GET_PATH//\//"${_STAR_DIR_SEPARATOR}"} " | head -n1 | cut -d' ' -f2-
}

main() {
    local value

    value="$1"
    if [[ ! -d "$value" ]]; then
        echo -e "Invalid dir value: $value\n"
        usage
        exit 1
    fi
    DIR=$(realpath "$value")
    shift

    while [[ $# -gt 0 ]]; do
        opt="$1";
        shift;
        case "$opt" in
            "--" ) break 2;;
            "-" ) break 2;;
            "-f"|"--format="* )
                if [[ ${#opt} -eq 2 ]]; then
                    value="$1"
                    shift
                else
                    value="${opt#*=}"
                fi
                FORMAT="$value"
                MODE=$MODE_CUSTOM_FORMAT
                ;;
            "-p"|"--paths" )
                MODE=$MODE_PATHS
                ;;
            "-n"|"--names" )
                MODE=$MODE_NAMES
                ;;
            "-P"|"--get-path="*)
                if [[ ${#opt} -eq 2 ]]; then
                    value="$1"
                    shift
                else
                    value="${opt#*=}"
                fi
                GET_PATH="$value"
                MODE=$MODE_GET_PATH
                ;;
            "-N"|"--get-name="*)
                if [[ ${#opt} -eq 2 ]]; then
                    value="$1"
                    shift
                else
                    value="${opt#*=}"
                fi
                GET_NAME="$value"
                MODE=$MODE_GET_NAME
                ;;
            "-s"|"--sort="* )
                if [[ ${#opt} -eq 2 ]]; then
                    value="$1"
                    shift
                else
                    value="${opt#*=}"
                fi

                if [[ "$value" != "$SORT_NAME" && "$value" != "$SORT_LOADED" && "$value" != "$SORT_NONE" ]]; then
                    echo -e "Invalid sort value: $value\n"
                    usage
                    exit 1
                fi
                SORT="$value"
                ;;
            "-o"|"--order="* )
                if [[ ${#opt} -eq 2 ]]; then
                    value="$1"
                    shift
                else
                    value="${opt#*=}"
                fi

                if [[ "$value" != "$ORDER_DESC" && "$value" != "$ORDER_ASC" ]]; then
                    echo -e "Invalid order value: $value\n"
                    usage
                    exit 1
                fi
                ORDER="$value"
                ;;
            "-i"|"--index="* )
                if [[ ${#opt} -eq 2 ]]; then
                    value="$1"
                    shift
                else
                    value="${opt#*=}"
                fi

                if [[ "$value" != "$INDEX_DESC" && "$value" != "$INDEX_ASC" ]]; then
                    echo -e "Invalid index value: $value\n"
                    usage
                    exit 1
                fi
                INDEX="$value"
                ;;
            "-b"|"--broken" )
                TYPE_TEST="-xtype l"
                ;;
            *)
                echo -e "Invalid option/argument: $opt\n"
                usage
                exit 1
                ;;
        esac
    done

    if [[ ! -n $DIR ]]; then
        echo -e "Directory in which to search is unset. Set it with '--dir' option.\n"
        usage
        return 2
    fi
    if [[ ! -d $DIR ]]; then
        echo -e "Directory in which to search does not exist: '$DIR'.\n"
        return 2
    fi

    case "$MODE" in
        "$MODE_NAMES" )
            list_names
            exit $?
            ;;
        "$MODE_PATHS" )
            list_paths
            exit $?
            ;;
        "$MODE_CUSTOM_FORMAT" )
            list_custom_format
            exit $?
            ;;
        "$MODE_GET_NAME" )
            get_item_name
            exit $?
            ;;
        "$MODE_GET_PATH" )
            get_item_path
            exit $?
            ;;
    esac
}

main "$@"